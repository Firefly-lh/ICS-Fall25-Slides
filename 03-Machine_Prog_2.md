---
theme: academic
highlighter: shiki
title: 03-Machine Prog II
info: |
  ICS 2025 Fall Slides
  Inspired by Arthals
  Presented by Firefly
presenter: false
titleTemplate: '%s'
class: text-center
drawings:
  persist: false
transition: fade-out
mdc: true
layout: cover
---

# 03-Machine Programming II

信息与计算科学 连昊

---

# 关于阶段测试
- 整体情况
  - 卷子难度较易, 题量少, 注重细节
  - 课程均分80, 中位数87
  - 小班均分81.6, 中位数87.5
- 希望大家
  - 考的好的同学继续努力, 考的差的同学也不要灰心 **(only 10pts)**
    - 陆老师说下次考试可能在在灵活性和难度上会有所提升, 但还是以友好为主
  - 注重基础, 复习时更多围绕**研讨题和作业题**展开复习 ~~(至少把原题稳稳的拿到手)~~
  - 考试的时候注意审题和计算, 尽量减少非知识性错误
    - 觉得有歧义的题目可以**向监考的助教问**

---

# 试卷讲评
- 改分原则
  - 计算分数错误/登分错误的, 可以改为正确的分数
  - 和官方答案一致/表述相近但被批改错误的, 可以获得对应题目的分数
  - 和官方答案不一致, 但你觉得正确的, 可以课上/课下找我讨论, 有机会argue得到分数
- 已确认可以加分的题目
  - 13题: `mask << n` 写成 `mask << (n & 0xff)` 或 `mask << (n % 256)` 或 `mask << ((char) n)`
    - 这题其实小班课讲过, 使用`%cl`寄存器是移位操作的默认行为, 不推荐大家画蛇添足

---

# 作业题

Homeworks

3.66 主要程序的翻译如下, `NR(n) = 4n+1`, `NC(n) = 3n`

```c
# long sum_col(long n, long A[NR(n)][NC(n)], long j)
# n in %rdi, A in %rsi, j in %rdx
sum_col:
  leaq 1(,%rdi,4), %r8        # t1 = n*4 + 1
  leaq (%rdi,%rdi,2), %rax    # t2 = n*3
  movq %rax, %rdi             # t3 = n*3
  testq %rax, %rax            # test n*3
  jle .L4                     # n*3 <= 0, jump .L4
  salq $3, %r8                # t1 = t1*8 = 8*(n*4 + 1)
  leaq (%rsi,%rdx,8), %rcx    # t4 = j*8 + A
  movl $0, %eax               # t2 = 0
  movl $0, %edx               # t5 = 0
.L3:
  addq (%rcx), %rax           # t2 = *(t4) = *(A + j*8)
  addq $1, %rdx               # t5 = t5+1
  addq %r8, %rcx              # t4 = t1+t4 = A + j*8 + 8*(n*4 + 1)
  cmpq %rdi, %rdx             # cmp t5 & t3
  jne .L3                     # if t5 != n*3, loop
```

---
layout: image-right
image: 03-Machine Prog II/3-1.png
backgroundSize: 60%
---

# 作业题

Homeworks

3.67

A. 如右图所示, 注意所有的数组/结构体/被取地址的变量需要存在栈上

B. 通过`%rdi = %rsp + 64`传递了一个用于存放`strA s`的起始地址

C. 通过`%rsp + offset`进行访问

D. 通过`%rdi`进行访问 (最后也通过`%rax = %rdi`返回了结果结构r的地址)

---
layout: image-right
image: 03-Machine Prog II/3-2.png
backgroundSize: 60%
---

# 作业题

Homeworks

3.67

E. 如右图所示, 依然是通过`%rsp + offset`的方式访问结果结构r

F. 调用者在栈上分配空间并将空间地址传递给被调用者，被调用者在该空间区域存储数据并返回此地址

---

# 作业题

Homeworks

3.68 主要程序解释如下 (注意结构体在栈中的对齐)

```c
# void setVal(str1* p, str2* q)
# p in %rdi, q in %rsi
setVal:
  # 8(%rsi) fetch q->t, int t is aligned by 4, so 4 < B <=8
  movslq 8(%rsi), %rax

  # 32(%rsi) fetch q->u, long u is aligned by 8
  # offset q->s is offset q->t + 4, so 24 < 12 + A*2 <= 32
  addq 32(%rsi), %rax

  # 184(%rdi) fetch p->v, long y is aligned by 8, so 176 < A*B*4 <= 184
  movq %rax, 184(%rdi)
  ret
```

根据上述三个不等式, 可以确定唯一的一组结果`A = 9, B = 5`

---

# 关于Attack Lab

- **截止时间: 10月23日晚23:59**
- 一些可能用到的前置知识
  - gdb调试器的使用 (你应该在bomb lab就掌握的差不多了)
  - 基础的代码注入和攻击方法 (请**仔细阅读writeup**, 并了解课本3.10.3和3.10.4的对应内容)
  - `objdump -d xxx > xxx.s`: 用于得到可执行文件的反汇编文件
  - `./hex2raw < xxx.txt > xxx.txt`: 用于将文本输入转化为二进制输入文件
  - `gcc -c xxx.s && objdump -d xxx.o > xxx.byte`: 用于将你需要的汇编代码编译为机器码
- 一些常见的坑
  - 请确保你的gadget都在`farm.c`的范围内, **越界的gadget无法通过在线评测**
    - 如果找不到合适的gadget, 你可能需要考虑使用`0x90`作为`nop`, 以扩大范围查找
  - 请确保栈指针始终**保持16字节对齐**, 否则你会得到经典的`segmentation fault`
  - 使用txt文本作为输入时, 请**确保每个字节间始终有一个空格(包括换行时)**

---

# 重点知识纲要

- 基本概念: 过程和运行时栈
  - 基本机制: 传递控制 / 传递数据 / 分配和释放内存
  - **栈和栈帧的组织方式**
    - 从高地址向低地址增长, 通过`%rsp`和`%rbp`进行寻址管理, 通过`push`和`pop`管理栈上数据
    - 通用的栈帧结构 (课本P164 图3-25)
      - 重点: **被调用者的返回地址属于调用者的栈帧**
  - 转移控制: `call`和`ret`指令及对应执行方式 (关注是如何修改PC的)
  - 数据传送: 前6个参数通过寄存器传递(回忆下哪6个?), 多余的参数和无法通过寄存器传递的参数通过栈传递
    - 通过栈传递的参数, 越靠前的参数越靠近栈顶(低地址)
    - **通过栈传递参数时, 所有的数据大小都向8的倍数对齐** (具体的, 可以参考课本P169 图3-29的示例)

---

# 重点知识纲要

- 栈上的局部存储 (这里依然需要着重关注对齐)
  - **三个需要依靠栈存储的情况**
    - 寄存器不够存放所有的本地数据
    - 对一个局部变量使用了取地址符`&`, 需要为其产生一个地址
    - 数组和struct, 它们无法通过寄存器存储
  - 调用者和被调用者保存寄存器 (掌握各个寄存器对应的类型)
    - 不要把这两个搞反了! 你可以理解为(被)调用者(负责)保存的寄存器
  - **递归过程中的栈帧分析** (难点, 可以结合往年题加深理解, 如2021期中第三题)

---

# 重点知识纲要

- 数组的分配和访问
  - `T A[N]`
    - `A`是数组名, 可以理解为数组首地址的指针
    - `T`是数组元素类型, `N`是长度, 这个数组在定义时需要分配`T * N`的空间
  - 指针的运算: **指针的加减会自动乘以步长**, 所以不需要手动的乘上步长
    - 回忆下**比例变址寻址**, 比例因子帮我们实现了这一优化
  - 数组的访问
    - 本质即指针的运算和取地址
    - 多维数组在内存中按照**行优先**的原则进行存储
  - 定长数组和变长数组(简单了解即可)
    - 对于定长数组的访问, 编译器可以进行一定优化(关注课本P180 图3-37的实例)
    - 对于变长数组则很多优化无法进行, 比如不能用移位和加法实现对数组长度n进行乘法指令的替换
  - 一个重点题型: 复杂表达式的解码(函数/指针/数组/函数指针的嵌套定义)以及和`sizeof`的结合分析

---

# 重点知识纲要

- 结构体(struct)和联合(union)
  - 结构体: 类似数组, 把不同类型的各个组成成分存在内存的一段连续区域内
    - 访问方式: 和数组一致, 头指针+偏移量
  - 联合: 允许用不同数据类型来引用同一内存地址的对象
    - 本质: 位表示不变, 解读方式改变 **(通常和数据类型的转换联系在一起考)**
    - 注意字节顺序(大端/小端)会对数据类型的解读顺序产生影响
  - 数据对齐
    - 结构体和联合的对齐: 内部对齐, 外部对齐和重排
    - 栈帧和某些特殊函数的强制对齐 (参考课本P191 旁注)
- 程序的攻击与保护(基本了解即可)
  - 常用的攻击方法: 内存越界引用/缓冲区溢出/ROP攻击 (通过Attack lab, 你应该会对它们更熟悉~)
  - 常用的保护方式: 栈随机化/栈破坏检测(金丝雀值)/限制可执行代码区域
- 变长栈帧和浮点代码(简单了解即可)

---
layout: end
---

# Thanks for listening!

