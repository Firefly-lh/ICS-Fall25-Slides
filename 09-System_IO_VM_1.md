---
theme: academic
highlighter: shiki
title: 09-System IO & VM I
info: |
  ICS 2025 Fall Slides
  Inspired by Arthals
  Presented by Firefly
presenter: false
titleTemplate: '%s'
class: text-center
drawings:
  persist: false
transition: fade-out
mdc: true
layout: cover
---

# 09-System IO & VM I

信息与计算科学 连昊

---

# 作业题

Homeworks

10.6  
- 答案: `fd2 = 4` 
  - 关键点1: 0, 1, 2是系统保留的文件描述符, 分别对应`stdin`, `stdout`, `stderr`
  - 关键点2: `Open`函数返回的描述符总是**当前没有打开**的**最小**描述符


10.10 只呈现补充的代码(读取文件并写入)

```c
  if (argc == 2) {
    int fd = Open(argv[1], O_RDONLY, 0);
    while ((n = Rio_readn(fd, buf, MAXBUF)) != 0)
      Rio_writen(STDOUT_FILENO, buf, n);
    exit(0);
  }
```

---

# 作业题

Homeworks

9.11 **考试重点题型, 我们后面重点讲解**

(1) 
```
  13 12 11 10  9  8  7  6  5  4  3  2  1  0
 +--|--|--|--|--|--|--|--|--|--|--|--|--|--+
 | 0| 0| 0| 0| 1| 0| 0| 1| 1| 1| 1| 1| 0| 0|
 +--|--|--|--|--|--|--|--|--|--|--|--|--|--+
```

(2) `0x09`, `0x01`, `0x02`, `No`, `No`, `0x17`

(3) 
```
  11 10  9  8  7  6  5  4  3  2  1  0
 +--|--|--|--|--|--|--|--|--|--|--|--+
 | 0| 1| 0| 1| 1| 1| 1| 1| 1| 1| 0| 0|
 +--|--|--|--|--|--|--|--|--|--|--|--+
```

(4) `0x00`, `0x0F`, `0x17`, `No`, `--`

---

# 作业题

Homeworks

9.12

(1) 
```
  13 12 11 10  9  8  7  6  5  4  3  2  1  0
 +--|--|--|--|--|--|--|--|--|--|--|--|--|--+
 | 0| 0| 0| 0| 1| 1| 1| 0| 1| 0| 1| 0| 0| 1|
 +--|--|--|--|--|--|--|--|--|--|--|--|--|--+
```

(2) `0x0E`, `0x02`, `0x03`, `No`, `No`, `0x11`

(3) 
```
  11 10  9  8  7  6  5  4  3  2  1  0
 +--|--|--|--|--|--|--|--|--|--|--|--+
 | 0| 1| 0| 0| 0| 1| 1| 0| 1| 0| 0| 1|
 +--|--|--|--|--|--|--|--|--|--|--|--+
```

(4) `0x01`, `0x0A`, `0x11`, `No`, `--`


---

# 作业题

Homeworks

9.13

(1) 
```
  13 12 11 10  9  8  7  6  5  4  3  2  1  0
 +--|--|--|--|--|--|--|--|--|--|--|--|--|--+
 | 0| 0| 0| 0| 0| 0| 0| 1| 0| 0| 0| 0| 0| 0|
 +--|--|--|--|--|--|--|--|--|--|--|--|--|--+
```

(2) `0x01`, `0x01`, `0x00`, `No`, `Yes`, `--`

(3) & (4) 缺页, 故无法找到对应的物理地址, 无需填写

---

# 重点知识纲要
- Unix I/O
  - 核心: 一种简洁统一的抽象形式
    - 一个文件是一个字节序列, 所有的I/O设备都被模型化为文件, 内存的输入输出转化为文件的读写
  - 打开文件: 进程中的程序向内核申请访问文件, 内核返回一个非负整数, 称为**描述符**
    - **why描述符?**: 内核为每个文件维护了相关的数据结构, 进程只需要记住这个数据结构的索引
    - Linux创建每个进程时都有三个打开的文件, 标注输入(描述符为0), 标准输出(描述符为1), 标准错误(描述符为2)
  - 改变文件位置: 内核为每个文件维护一个文件位置$k$, 表示当前位置到文件开头的字节偏移量, 程序能够执行`seek`操作, 显式地改变文件位置
  - 读写文件: 复制文件中的字节到内存(写) / 从内存中复制字节到文件(读), 注意读的时候可能有`EOF`条件
  - 关闭文件: 进程中的程序向内核申请关闭文件, 内核释放文件相关的数据结构, 并将其描述符恢复为可用状态
    - **当一个进程因任何原因终止时, 内核都会关闭其打开的所有文件并释放内存资源**

---

# 重点知识纲要
- 文件
  - 普通文件: 分为文本文件(只包含ASCII或者Unicode字符, 可以直接打开阅读)和二进制文件(其它普通文件, 不可直接打开)
    - Linux文本文件是一个**文本行序列**, 使用新行符`\n`进行划分, 其ASCII码为`0x0a`
  - 目录
    - 包含一组链接的文件(可以理解为树), 每个链接都将一个文件名映射到一个文件(普通文件或目录)
      - 特别的, `.`是到该目录自身的链接, `..`是到该目录的父目录的链接
    - 绝对路径: 从根目录`/`开始的路径; 相对路径: 从当前工作目录`.`开始的路径
    - 熟悉相关的操作指令: `mkdir`, `ls`, `rmdir`, `tree`, `cd`
  - 套接字(socket)
    - 用于跨网络通信的文件(第十一章的重点)

---

# 重点知识纲要
- 系统级I/O函数(同样的, 你需要熟悉这些api的作用, 参数和返回值)
  - 打开文件: `open`函数(最重点, 各个`flags`和`mode`参数的作用都要掌握)
    - `open`函数返回的描述符总是**当前没有打开**的**最小**描述符
  - 关闭文化: `close`函数, 关闭一个已关闭的描述符会报错
  - 读写文件: `read`和`write`函数(这一块重点关注下返回值)
    - `read`和`write`函数成功执行时总是返回读取/写入的字节数(特别的, 读到`EOF`时`read`函数返回0)
    - 当返回值小于输入的`n`, 但不为表示错误的`-1`时, 称这样的返回值为**不足值**
      - 导致不足值的情况: 读时遇到`EOF` / 从终端读取文本行 / 读写套接字
      - 为了处理不足值(尤其是网络通信时), 很多时候我们需要不断的调用`read`和`write`函数 (你会在计网里遇到它)
    - 稍稍关注下课本P626的旁注, `ssize_t`和`size_t`的区别
  - 读取文件元数据和读取目录内容 (相对来说不是重点, 自行简单了解)

---

# 重点知识纲要

- RIO包 (更健壮的读写, 稍微关注下具体代码实现)
  - RIO的**无缓冲的**输入输出函数 `rio_readn`和`rio_writen`
    - 核心改进: 自动处理了不足值的情况, 适用于网络程序这类容易出现不足值的场景
    - 注意: **无缓冲**并不等于**无缓冲区**, 前者指的是没有对`read`函数实现缓冲机制, 后者指的是文件读写中存放数据的缓冲区
  - RIO的**带缓冲的**输入函数 `rio_readlineb`和`rio_readnb`
    - 核心改进: 由于`read`为内核函数, 调用效率不高(需要依靠信号处理程序), 因此在`read`过程中引入缓冲区, 实现**类似缓存的机制**, 来减少系统调用的次数
    - 具体的, 不再是调用一次`read`函数读取$n$个字符, 而是单次调用`read`函数尽量填满内存中的缓冲区, 后续从缓冲区中逐渐读取$n$个字符, 直到缓冲区中字符数不足时再进行补充
  - 注意, **带缓冲的和无缓冲的输入函数不能混用**

---

# 重点知识纲要

- 共享文件 **(重点:理解三张表)**
  - 描述符表: 内核为每个进程维护独立的描述符表, 其由文件描述符索引, 表项指向文件表中的一个表项(类似跳转表)
  - 文件表: 所有进程共享, 存储已打开文件的信息(如: 当前文件的位置 / 引用计数 / 指向v-node表项的指针)
    - 引用计数: 当前指向该表项的描述符表项数(人话就是几个进程"打开"了这个文件)
      - 这里的"打开"不是同一进程的多次调用`open`, 而是父子进程的文件描述符共享
    - 内核删除一个文件在文件表中的表项, 当且仅当该文件的引用计数为0(没有进程在打开这个文件)
  - v-node表: 所有进程共享, 存储文件的元数据(`stat`结构中的大多数信息)
  - **重点1: 文件表是可重的, 每个表项对应着一次打开; v-node表是不可重的, 每个表项对应着一个文件**
  - **重点2: 关注父子进程如何共享文件表集合**(课本P636 图10-14)
- I/O重定向
  - 本质: 修改**描述符表项**, 并对应的**更新文件表项**
  - 核心函数: `dup`和`dup2` (注意`dup2`的参数顺序, 是用前面的参数的表项覆盖后面参数的表项)
- I/O函数的选用(10.11节, 在大家代码实践的时候挺重要的, 推荐阅读下)

---

# 重点知识纲要

- 虚拟内存
  - 核心: 计算机底层又一种简洁统一的抽象形式
    - 为每个进程提供了一致的地址空间, 简化了内存管理
    - 保护每个进程的地址空间不被其它进程破坏
  - 基本概念: 物理地址 / 物理地址空间 / 虚拟地址 / 虚拟地址空间(都可以类比成数组理解)
    - 寻址: 虚拟地址通过内存上的内存管理单元(MMU)翻译为物理地址, 再根据物理地址到主存中访问
    - 注意: 虚拟地址空间要求其大小$N$为2的幂次, 而物理地址空间不要求

---

# 重点知识纲要

- 虚拟内存作为缓存的工具
  - 核心: 为实现和物理内存缓存的相统一, 虚拟内存也需要实现类似的缓存机制, 基于此我们**可以将缓存的检查提前到虚拟内存阶段**
  - 页: 虚拟内存中交换的最小单位, 按相同的大小将物理内存和虚拟内存划分为物理页和虚拟页
    - 任意时刻, 虚拟页的集合可分为不相交的三个子集: 未分配的(这一虚拟页和物理页还未关联); 未缓存的(这一虚拟页关联的物理页未缓存在物理内存中); 已缓存的(这一虚拟页关联的物理页已缓存在物理内存中)
  - 页表(PTE, 用来判断一个页是否被缓存)
    - 页表条目: 一个有效位 + 一个n位地址字段
      - 有效位为0表示一个页不在物理内存中, 对应的, 若**页表项为空**表示**该页未分配**, 为**虚拟页起始地址**表示**该页未缓存**
      - 有效位为1表示一个页已缓存在物理内存中, 对应的页表项为物理页的起始地址
    - 页表总是常驻在主存中, 属于**DRAM缓存**, 由于其**不命中惩罚极大**, 因此采用**全相联结构**

---

# 重点知识纲要

- 基本概念(类比缓存)
  - 页命中: 有效位为1, 直接根据条目读取地址
  - 缺页: 触发**缺页异常**(回忆下ECF里的对应内容), 内核中的缺页异常处理程序选择一个**牺牲页**(若其已被修改, 执行牺牲时写回), 而后牺牲页被新页替换, 并对应修改页表条目
  - 分配页面: 如调用`malloc`函数, 会在磁盘上创建一个空间, 将一个**未分配的**虚拟内存页指向该物理页, 并对应修改页表
- 虚拟内存用作内存管理的工具: 提供一个每个进程独占物理内存的假象
  - 好处: 简化链接 / 简化加载 / 简化共享 / 简化内存分配(自行读书)
- 虚拟内存用作内存保护的工具
  - 在页表条目中包含多个权限位(如`SUP`, `READ`, `WRITE`), 用于指示对对应页的操作权限, 如果违反许可, 就会触发**一般保护故障**, 在Linux中对应**段错误(Segmentation Fault)**
- 虚拟内存地址的翻译 **(重中之重, 在把握基础的前提下, 适当根据往年题拓展)**

---
layout: end
---

# Thanks for listening!