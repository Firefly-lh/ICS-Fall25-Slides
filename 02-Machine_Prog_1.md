---
theme: academic
highlighter: shiki
title: 02-Machine Prog I
info: |
  ICS 2025 Fall Slides
  Inspired by Arthals
  Presented by Firefly
presenter: false
titleTemplate: '%s'
class: text-center
drawings:
  persist: false
transition: fade-out
mdc: true
layout: cover
---

# 02-Machine Programming I

信息与计算科学 连昊

---

# 关于Bomb Lab

- 截止日期:调整至**10月8日**, 国庆不要玩忘记了(
- 前置知识:GDB调试器的使用
  - 你可以参考课本3.10, writeup和其它网上资料
  - 请**务必**在开始完成Lab前, 参照[Arthals的教程](https://www.bilibili.com/video/BV1RFxheeEcy/?spm_id_from=333.337.search-card.all.click)设置好断点
- 今年的secret_phase有5分额外得分(上限不超过100分), 如果你不幸引爆了炸弹, 可以尝试通过其弥补
- 思路提示
  - 以跳转处为边界, 分模块阅读汇编代码, 理清每个部分的功能
  - 大胆猜测, 抓住核心代码的语句推测整体功能
  - 如果你使用txt输入, 请**确保文本末尾有一个额外的空行**
- 有任何疑问, 欢迎与同学/助教/树洞交流思路

---

# 作业题

Homeworks

3.58

```c
long decode(long x, long y, long z) {
  y = y - z;
  x = x * y;
  long tmp = y;
  return x ^ (tmp << 63 >> 63);
}
```

---

# 作业题

Homeworks

3.59

- $x \cdot y = 2^{128} x_h y_h + 2^{64} x_l y_h + 2^{64} x_h y_l + y_h y_l = 2^{64} x_l y_h + 2^{64} x_h y_l + x_l y_l$
  - 这里由于$2^{128}$溢出, 直接舍去

```c
# dest in %rdi, x in %rsi, y in %rdx
store_prod:
  movq %rdx, %rax     # %rax = y
  cqto                # 对y进行符号拓展 %rdx中存储y_h(这里只会是0或-1)
  movq %rsi, %rcx     # %rcx = x  
  sarq $63, %rcx      # %rcx中存储x_h(这里只会是0或-1)
  imulq %rax, %rcx    # x_l * y_h
  imulq %rsi, %rdx    # x_h * y_l
  addq %rdx, %rcx     # 2^64 * (x_l * y_h + x_h * y_l)
  mulq %rsi           # x_l * y_l
  addq %rcx, %rdx
  movq %rax, (%rdi)   # 设置乘积的低64位
  movq %rdx, 8(%rdi)  # 设置乘积的高64位
  ret
```

---

# 作业题

Homeworks

3.60

- A. `x in %rdi` `n in %esi` `result in %rax` `mask in %rdx`
- B. `result = 0` `mask = 1`
- C. `mask != 0`
- D. `mask = mask << n` (这里注意寄存器是`%cl` 后面会讲到)
- E. `result |= (x & mask);`
- F.

```c
long loop2(long x, int n) {
  long result = 0;
  long mask;
  for (mask = 1; mask != 0; mask <<= n) {
    result |= (x & mask);
  }
  return result;
}
```

---

# 作业题

Homeworks

3.63 (回忆下switch在C语言中是怎么执行的)

```c
long switch_prob(long x, long n) {
  long result = x;
  switch(n) {
    case 60:
    case 62:
      result = x * 8;
      break;
    case 63:
      result = x >> 3;
      break;
    case 64:
      x = x << 4 - x;
    case 65:
      x = x * x;
    default:
      result = x + 0x4B;
  }
  return result;
}
```

---

# 重点知识纲要

- 基本概念: 指令集体系架构(ISA, 这部分内容会在第4章更多涉及) / 汇编代码 / 机器代码
- 基础的汇编和反汇编操作(这部分内容会在第7章更多涉及)
  - `.c` `.s` `.o`文件对应的类型以及`-Og/-O1/-O2/-O3`参数的意义
  - `objdump`指令的使用方法
  - 补充:ATT和Intel汇编代码格式的差异(课本P118 旁注)
- **数据格式**(课本P119 图3-1)
- 程序计数器(PC, 课本P113)
- 16个通用目的寄存器
  - 所有寄存器的四个名字和它们的作用(课本P120 图3-2)
    - 调用者保存/被调用者保存/参数的传递(结合栈进行理解 3.7节)
  - **两条重要规则**
    - 生成1字节和2字节数字的指令会保持剩下的字节不变;
    - 生成4字节数字的指令会把高位的4个字节置为0.

---

# 重点知识纲要

- 信息的访问
  - 基础概念: 立即数, 内存(可以看成一个根据索引访问的字节数组)和寄存器
  - 掌握各种寻址模式, 尤其是**比例变址寻址**(课本P121 图3-3)
    - 基址和变址寄存器都必须是**64位寄存器**
    - 比例因子s必须是**1, 2, 4, 8**
    - **注意:** `(,ri,s)`和`Imm(,ri,s)`,前导的`,`不可以省略
  - 数据传送指令(MOV系列)
    - 一定牢记对于两个操作对象, 前者为来源(S), 后者为目的地(D), **来源和目的地不能都是内存**
    - `movx`: 后缀x与传送的数据类型相匹配
      - `movl`指令以寄存器为目的地时, 会将高位的四字节清零
      - `movabsq`的目的地只能是寄存器, 源只能是立即数
    - `mov(z/s)xy`: 将后缀x对应的数据类型在传送时零扩展/符号扩展为后缀y对应的数据类型
      - `cltq`: convert long to quad, 只针对寄存器`%rax`
      - 没有`movzlq`, 因为其等价于`movl`

---

# 重点知识纲要

- `pushq`和`popq`指令:结合3.7节的栈一起理解 重点关注课本P127 图3-8的**两步拆分**
  - `popq`操作并不会将栈上对应的值删除, 其总是会保留在栈上直到被覆盖
- 算数与逻辑操作(课本P129 图3-10 ~~全部背下来即可~~)
  - `leaq`: load effective address, "加载有效地址", 注意区分和`movx`的区别, 前者传地址, 后者传值
    - `leaq`只能以寄存器作为目的地, 且`leaq`不改变任何条件码
    - 很多时候`leaq`的主要作用是通过比例寻址的方式, 对寄存器内存储的值做计算
  - 一元操作和二元操作: 分清源和目的即可
  - 移位操作: 分清算数移位`SAL/SAR`和逻辑移位`SHL/SHR`
    - 移位量只能是立即数, 或者放在单变量寄存器`%cl`中 (回忆下C语言移位量溢出时是如何计算的)
  - 特殊的算术计算: 分清有符号乘除法`imulq/idivq`和无符号乘除法`mulq/divq`
    - `cqto`: 64位整数 -> 128位整数(符号拓展)
    - 注意寄存器`%rdx`和`%rax`在乘除法运算中分别用来放什么
    - 注意除法运算中需要对被除数的高位提前进行处理(置为全0或全1)

---

# 重点知识纲要

- 条件码: ZF(零标志) / SF(符号标志) / CF(进位标志) / OF(溢出标志)
  - 重点: 区分"进位"和"溢出" 前者对应的是无符号数运算时发生的进位/**借位**(发生在最高位) 后者对应的是有符号数运算时发生的溢出(发生在最高位/次高位)
    - 关注课本P136页等价的C表达式
  - 细节
    - `leaq`指令不改变条件码
    - 对于逻辑操作`AND`,`OR`,`XOR`和`NOT`, 它们会将`CF`和`OF`设置为0
    - `INC`和`DEC`指令只只改变`ZF`和`OF`, 不设置`CF`
    - 移位操作会将`CF`设置为最后一个被移出的位, 将`OF`设置为0
  - `TEST`和`CMP`系列指令: 注意它们各自基于的运算(课本P136 图3-13), 只设置条件码, 不改变寄存器的值

---

# 重点知识纲要

- 条件码的访问 (还是老样子, 请注意**操作数的顺序**)
  - 各个条件
    - l(less) / g(great): 有符号数比大小
    - b(below) / a(above): 无符号数比大小
    - e(equal) / s(sign) / n(not): 是否相等/是否为负数(符号码)/否定
    - 等价的条件码表达式(即"效果"一栏)考的相对少, 但可以自己尝试去证明下
  - 'SET'系列(课本P137 图3-14): set+条件(条件为真时置1, 否则置0)
    - 目的的操作数只能是单字节寄存器/单字节长的内存位置, 如果希望得到32位/64位结果, 可以用`movz`系列指令对高位置零

---

# 重点知识纲要

- 'J'系列(课本P139 图3-15): jmp / j+条件(条件为真时跳转, 否则不跳转)
  - 直接跳转: 给出一个标号作为跳转目标(标号对应的地址需要提前定义), 如`jmp .L1`
  - 间接跳转(带*): 跳转目标从寄存器/内存中读出, 如`jmp *(%rax)`
  - 跳转地址的编码: 绝对地址(4字节) / **PC相对的(PC-relative, 课本3.6.4节)**
    - 将目标指令和**紧跟在跳转指令后面的那条指令的地址**之间的差作为编码
      - 执行PC相对寻址时, 程序计数器的值是跳转指令后面的那条指令的地址, 而不是跳转指令本身的地址
      - 注意: 地址偏移量是**有符号的**, 且注意**小端码**的编码方式(这部分在第4章会更多涉及)
    - 优势
      - 地址偏移量可以是1, 2, 4字节, 编码更加灵活简洁
      - 目标代码可以不做改变就移动到内存中的不同位置(后面会介绍**位置无关的代码**)
  - 条件跳转(使用控制的条件转移)
    - 注意条件分支一般被翻译为`if(!t) goto false;`(课本P143)

---

# 重点知识纲要

- 条件传送(使用数据的条件转移):`CMOV`系列(课本P147 图3-18)
  - 与流水线有关(第4章会涉及), 效率**通常**更高, 但适用范围较小
    - 只有当`else`和`then`的结果都容易计算且无副作用时会使用条件传送
  - 不支持单字节的条件传送
  - 条件传送的**目标只能是寄存器**, 汇编器可以根据目标寄存器的名字推断出条件传送指令的操作数长度, 因此无需显式编码
  - 关注课本P146旁注, 如何计算分支预测错误的处罚?
- `do-while`的翻译方式 / `while`的两种翻译方式 / `for`的翻译方式

---

# 重点知识纲要

- `switch`语句的翻译方式
  - 方法1: 一系列`if-else`语句
  - 方法2: 引入跳转表这一数据结构
    - 适用情况: 开关情况数量多(如4个以上)且值的范围跨度小
    - 做法(课本P161页代码):
      - 在汇编代码的`.rodata`字段(read-only data, 只读字段)中, 用连续的内存地址存放一张跳转表, 每一个表项对应`switch`语句一个分支所执行代码对应的地址
      - 在`switch`对应的汇编语句中, 使用间接跳转的进行跳转
      - 一些进一步的优化
        - 落入其它分支的情况 --- 无`break`语句
        - 未被提及的索引 ---  `default`语句
        - 初始优化 --- 将起点对应的case调整至0, 方便寻址(此时负数索引可能变为大正数)
    - 优势: 用空间换时间, 执行开关语句的时间与开关情况的数量无关

---

# 关于阶段测试

- **时间:10月13日, 随堂测试**
- 形式: 笔试, 具体考试时长和题型暂未通知
- 范围: 第二章和第三章全部内容
  - 注意: 这中间没有其他小班课了, 大家自己安排时间, 充分复习(课本+往年题)
  - 后续的栈帧部分以及`struct`和`union`都是考试的重难点, 后续有时间的话我会整理一份重点纲要+一些推荐的往年题同步到群里
- 请好好完成Bomb Lab, 锻炼阅读大段汇编的能力
- 下两周回课的同学可以先不用提前准备, 可能会根据情况安排大家一起做试题讲解
- Have a good luck!

---
layout: end
---

# Thanks for listening!