---
theme: academic
highlighter: shiki
title: 07-Linking & ECF I
info: |
  ICS 2025 Fall Slides
  Inspired by Arthals
  Presented by Firefly
presenter: false
titleTemplate: '%s'
class: text-center
drawings:
  persist: false
transition: fade-out
mdc: true
layout: cover
---

# 07-Linking & ECF I

信息与计算科学 连昊

---

# 友情提醒

- Cache Lab截止时间: **11月13日晚23:59** 请及时完成
- 第二次阶段测试
  - 时间: 11月17日 下午5-6节 随堂测试
  - 考试形式: 和第一次阶段测试一致 题型上可能更加灵活
  - 考试范围: 第四章-第八章
    - 理论上不直接考察第二, 三章内容, 但可能涉及相关知识(如: 基本的汇编指令)
  - 复习建议
    - 这部分需要记忆的内容较多 尽量**完整梳理一遍课本**
    - 复习时重点关注研讨题中涉及的知识点 重点掌握作业题涉及的题型 ~~(至少原题别错)~~
    - 对于重难点章节(如: 第四/六章) 适当拟合往年题进行练习

---

# 作业题

Homeworks

7.6 链接部分需要掌握的**重点题型** (对应7.5节和练习题7.1)

- `buf`: 有符号表条目; m.o; 外部符号; .data节 (`extern` 声明的外部变量, 在m模块中定义在`.data`节, 在swap模块中定义在`UNDEF`节, 考试的时候注意问的是哪个模块)
- `bufp0`: 有符号表条目; swap.o; 全局符号; .data节 (全局变量)
- `bufp1`: 有符号表条目; swap.o; 局部符号; .bss节 (未初始化的由`static`声明的静态全局变量)
- `swap`: 有符号表条目; swap.o; 全局符号; .text节 (全局函数)
- `temp`: 无符号表条目
- `incr`: 有符号表条目; swap.o; 局部符号; .text节 (由`static`声明的静态全局函数)
- `count`: 有符号表条目; swap.o; 局部符号; .bss节 (初始化为0的由`static`声明的静态局部变量)

---

# 作业题

Homeworks

7.8 链接部分需要掌握的**重点题型** (对应7.6节和练习题7.2)

A. `main.1` `main.2` (全局符号和局部符号不冲突)

注: 有同学前几天来问, 局部符号的解析是否只需要由编译器和汇编器负责, 不需要由链接器处理.
事实上, 根据课本的说法, 链接器需要对所有符号进行解析(相当于完整扫一遍符号表), 只是对于局部符号, 链接器可以维持汇编器已有的解析方式不变.(即不需要关联全局引用)

B. 未知 (对应规则3 多个同名的弱符号)

C. 错误 (对应规则1 多个同名的强符号)

---

# 作业题

Homeworks

7.12 链接部分需要掌握的**重点题型** (对应课本481页的公式和练习题7.5)

A. refaddr = ADDR(.text) + r.offset = 0x4004ea

  $\quad$ *refptr = (unsigned) (ADDR(swap) + r.addend - refaddr) = 0xa

B. refaddr = ADDR(.text) + r.offset = 0x4004da

  $\quad$ *refptr = (unsigned) (ADDR(swap) + r.addend - refaddr) = 0x22

---

# 作业题

Homeworks

8.9 考察基本概念 **(有重叠就算)**

`AB`: No `AC`: Yes `AD`: Yes `BC`: Yes `BD`: Yes `CD`: Yes

8.18 

阅读代码发现, 输出2意味着第一次`Fork`得到的子进程及其子进程调用了`exit`. 而在`exit`之前, 该进程必然输出过一次0/1, 由此A.C.E是可能的.

8.19 

$2^n$

---

# 重点知识纲要

- 代码的编译过程
  - .c(代码文件) $\xrightarrow{cpp(预处理器)}$ .i(中间文件) $\xrightarrow{ccl(编译器)}$ .s(汇编代码文件) $\xrightarrow{as(汇编器)}$ .o(可重定位目标文件)
  - 多个.o文件 $\xrightarrow{ld(链接器)}$ prog(可执行目标文件)
- 链接
  - 核心作用: **分离编译** (实现代码模块化/构建代码库/便于问题的查找和代码的维护)
    - 提升了时空效率: 修改代码时不需要重新编译整个代码, 只需要编译对应的小模块/库
  - **执行时间: 编译时, 加载时, 运行时均可执行**
- 静态链接: 多个.o文件直接完全链接, 得到可执行目标程序
  - 主要任务
    - 符号解析: 将每个符号引用正好和符号表中的一个符号定义关联起来
    - 重定位: 编译器和汇编器生成**从0开始的代码和数据节**. 链接器负责把**每个符号定义和一个具体的内存地址关联起来**, 从而重定位这些节, 再将对应的符号引用指向相应的内存地址.

---

# 重点知识纲要

- 目标文件 (字节块的集合)
  - 可重定位目标文件: 半成品的二进制代码和数据, 计算机不可直接执行
  - 可执行目标文件: 链接完成的二进制代码和数据, 可以直接复制到内存中并执行.
  - 共享目标文件: **特殊类型**的可重定位文件, 可在程序加载或运行时被动态地加载进内存并链接.
- 可重定位目标文件: 可执行可链接格式(ELF)
  - 主要关注ELF文件的组织格式和各个节的存储内容.
    - 重点: `.data`节用于存储已初始化的全局和静态C变量; `.bss`节用于存储未初始化(或初始化为0)的全局和静态C变量
      - `.bss`文件作为占位符, 不占用任何实际的空间, 从而提高的空间效率.
      - **局部C变量在运行时保存在栈中, 不会出现在两者中的任何一节**
  - 简要了解: ELF头中存储的内容和ELF文件的读取顺序

---

# 重点知识纲要

- `static`声明
  - 为其声明的函数/变量附加一个**静态**属性, 这些函数/变量只能在其声明模块中使用, 对其它模块不可见.
    - 同模块中重名的`static`变量, 由编译器负责生成不同名称的局部链接器符号.
- 符号和符号表: 每个可重定位目标模块m都维护一个符号表, 包含了m定义和引用的符号信息
  - 全局符号: 由模块m定义, 可被其它模块引用, **对应非静态的C函数和全局变量**
  - 外部符号: 由其它模块定义, 被模块m引用的符号, **对应其他模块中定义的非静态的C函数和全局变量**, 常通过`extern`关键字引用
  - 局部符号: 只被模块m定义和引用的符号, **对应静态的C函数和全局变量**
  - **重点: 非静态的局部变量不会出现在符号表中, 在运行时保存在栈上**
  - 简要了解: 符号表条目的具体结构
  - 重点关注: 符号表的三个伪节 **(只在可重定位目标文件中有)**
    - `ABS`(不该被重定位的符号); `UNDEF`(未定义的符号, 一般即外部符号)
    - `COMMON`: 未被分配位置的未初始化的数据目标, 现代GCC中指**未初始化的非静态全局变量**
      - 相对的, `.bss`中存储**未初始化的静态变量和初始化为0的静态和全局变量**

---

# 重点知识纲要

- 符号解析: 由链接器负责, 将符号表中的确定的符号定义和符号引用相关联
  - **重点: 多重定义的全局符号解析 (强弱符号+三条规则, 对应课本P471 7.6.1节)** 
    - 即使不违背上述规则, 也可能会存在类型混淆或意料之外的作用(参加7.6.1节中的几个例子), 因此写代码时尽量多用`static`声明静态变量
- 简要了解: 静态库的概念和引用方式
  - 重点关注: 静态库引用的解析方式 **(从左向右解析, 对于单个符号, 先引用后定义)**
    - 使用库的准则: 总是放在命令行结尾; 按依赖关系进行排序(拓扑排序)
- 重定位
  - 重定位节: 把所有可重定位目标文件中相同类型的节聚合为同一类型的新节, 并赋予运行时地址
  - 重定位符号: 通过**重定位条目**, 将每个符号引用指向相应的运行时地址
    - 了解重定位条目的结构, **重点掌握重定位地址的计算** (结合第四章里的PC-relative编码理解)
- 简要了解: 可执行目标文件的结构和加载
  - 关注ELF头结构, 段的概念, 加载过程中主函数的调用(`_start` -> `_libc_start_main` -> `main`)

---

# 重点知识纲要

- 简要了解: 动态链接(在**运行时**加载动态库并解析符号)
- 简要了解: 位置无关代码
  - 优势: 共享库可以被加载到内存的任何位置, 从而多个程序可以使用同一个共享库示例, 节省内存
  - 实现方式: PLT和GOP (疑似是不要求掌握了, 有余力的情况可以进行了解)
- 简要了解: 库打桩机制(在运行时截获对共享库函数的调用, 转而执行自己的函数)
  - 了解下三类库打桩机制的调用方式和对应效果
  - 小重点: 编译时打桩要求能够访问程序的源代码, 链接时打桩要求能访问程序的可重定位目标文件, 运行时打桩只要求访问可执行目标文件

---

# 重点知识纲要

- 基本概念: 控制流和控制转移 (按序列执行内存中的指令, 反应在PC的变化上)
- 异常: 控制流中的突变, 意味着处理器状态发生变化(前提), 通过异常跳转表将控制流转移到操作系统内核的异常处理程序中(操作), 最终返回或终止程序(结果)
  - 异常表: 每类异常被分配了唯一的非负整数**异常号**, 在对应的异常跳转表条目中存储了相应**异常处理程序的地址**, 额外用一个寄存器存储异常处理程序的基址
  - 异常的类别 **(重点掌握课本P504 图8-4 以及相应的解释文字)**
    - 特别的, 陷阱是**有意的异常**, 一般会指向系统调用, 进而请求内核的一些服务(见课本P507 图8-10)
      - 关于系统调用, 主要需要了解寄存器的使用(参数和返回值的传递, 课本P506)
  - 常见的异常 **(重点掌握课本P506 图8-9 以及相应的解释文字)**

---

# 重点知识纲要

- 进程: 一个执行中程序的实例
  - 每个进程的上下文中维护了一个程序运行所需的各种状态(程序的代码和数据, 栈, 通用目的寄存器的内容, PC, 环境变量和程序描述符集合)
  - 实现: 独立的逻辑控制流 **(上下文切换)** + 私有的地址空间 **(虚拟内存)**
  - 基本概念: 并发流/并发 **(重叠即可)**
  - 简要了解: 私有地址空间的结构(课本P510 图8-13) / 内核模式(相当于管理员, 能够任意访存和执行特权指令)
  - 上下文切换
    - 由**内核**进行**调度**(决定抢占当前进程, 并重新启动一个先前被抢占的进程)
    - 三步走: 保存当前进程上下文 -> 恢复下一个进程的上下文 -> 将控制权转交给新进程
- 简要了解: 系统调用错误函数
  - 当Unix系统级函数遇到错误时, 通常会返回-1, 并设置全局整数变量`errno`来指示错误的类型, 但基本的Unix系统级函数不包括错误检查. 因此, 在代码实现时, 可以用错误处理包装函数来同时完成Unix系统级函数的调用和错误检查. (大家会在tsh lab中更多的了解这一部分)

---

# 重点知识纲要

- 进程控制 **(你需要对这一部分用到的api了如指掌, 包括函数的作用, 参数和返回值)**
  - 每个进程都有一个唯一的正数进程ID(PID)
    - `getpid`函数用于获取调用进程的PID
    - `getppid`函数用于获取调用进程的父进程的PID
  - 进程的终止
    - 每个进程总是处在三个状态之一
      - 运行(在执行或等待被执行)
      - 停止(被挂起, 且不会被调度, 由信号控制)
      - 终止(永远停止, 不再被运行): 可能由于收到相应信号/从主程序返回/调用了`exit`函数

---

# 重点知识纲要

- 进程的创建
  - 重点掌握: `fork`函数, 创建了一个新进程(称为子进程, 原进程为父进程)
    - 重点1: **调用一次, 返回两次** (父进程中返回子进程的PID, 子进程中返回0, 用于区分父子进程)
    - 重点2: **相同但独立的虚拟地址空间** (得到的是虚拟地址空间的副本, 后续的本地修改互不影响, 但共享文件)
    - 重点3: **并发执行** (重点题型: 阅读进程相关代码, 分析相应输出 **核心是画分支图, 进行拓扑排序**)
- 进程的回收
  - 一个进程终止后必须被其父进程回收, 否则会成为**僵死进程**
  - 如果这个进程的父进程已经终止了, 则由`init`进程负责它的回收工作  
    - `init`进程的PID为1 在系统启动时便被创建 永不终止
  - 重点掌握: `wait`和`waitpid`函数(参数/返回值/作用/以及**各个宏定义**)
    - **程序不会按特定的顺序回收子进程**, 子进程的回收顺序是特定的计算机系统的属性
- 简要了解: 进程的休眠(`sleep`函数) 程序的加载和运行(`execve`函数)

---
layout: end
---

# Thanks for listening!