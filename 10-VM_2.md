---
theme: academic
highlighter: shiki
title: 10-VM II
info: |
  ICS 2025 Fall Slides
  Inspired by Arthals
  Presented by Firefly
presenter: false
titleTemplate: '%s'
class: text-center
drawings:
  persist: false
transition: fade-out
mdc: true
layout: cover
---

# 10-VM II 

信息与计算科学 连昊

---
layout: image-left
image: 10-VM II/pic1.png
backgroundSize: 90%
---

# 虚拟内存地址翻译

- 核心思路: 类似缓存, 对地址进行拆分翻译
  - Step1: 根据页大小确认VPO位数, 根据虚拟地址空间确认总位数, 进而得到VPN位数
  - Step2: 进一步拆分VPN, 根据快表(TLB)的set数确认TLBI位数, 进而得到TLBT位数
  - Step3: 读出TLBI和TLBT, 根据其访问快表, 若命中则直接得到物理页号 **(注意检查Valid)**
  - Step4: 否则读出VPN, 根据其访问页表, 若命中则直接得到物理页号, 未命中则执行缺页异常处理程序
- 最终物理地址: 物理页号和VPO(=PPO)拼接
- 进一步的, 可能还需要根据拿到的物理地址访问物理内存 **(对应第六章缓存)**

---

# 重点知识纲要

- 多级页表
  - 改进原因: 完整的页表常驻在物理内存中, 占据很大空间, 希望对它进一步拆分
  - 核心: 将原先的VPN根据页表级数等分为$VPN_i$, **i级页表条目存储i+1级页表的基址, $VPN_i$存储i级页表条目号**, 我们只需保存一级页表的基址, 即可对应进行寻址(可以理解为多叉树)
  - 好处: 只有一级页表需要常驻在物理内存中, 且占用空间大幅减小
- 拓展: 大页模式(参考2015期末第六大题)
  - 核心: 使用相比普通页更大的专有页来合并存储多级页表(相当于多维数组 -> 一维数组), 进而减少多级页表所需的翻译时间, 提高命中率
- Intel Core I7地址翻译
  - 重点1: 熟悉整体架构, 掌握课本P577图9-21和图9-22
  - 重点2: 物理页表要求4KB对齐, 因此可以在多级页表条目的低12位中存储页的相关信息(图9-23和图9-24)
  - 重点3: 优化地址翻译: 课本P579旁注, 物理地址访问和虚拟地址翻译可以部分并行

---

# 重点知识纲要

- Linux虚拟内存系统
  - Linux虚拟内存区域: 简单了解下虚拟内存的组织方式(课本P581 图9-27)
  - Linux缺页异常处理: 地址合法?(是否溢出) -> 访问合法?(是否有权限)
    - 若均合法, 正常缺页, 进行牺牲页的替换, 而后返回原先正在执行的指令(回忆下ECF相关知识)
    - 若虚拟地址不合法, 触发**段错误**, 直接终止进程
    - 若内存访问不合法, 触发**保护异常**, 直接终止进程 (特殊情况下允许返回, 如9.8.1讲到的**写时复制**)
- 内存映射 (阅读并熟悉相关内容即可, 可以参考A神的slides)


---

# 虚拟缓存大题练习

T1 (出处: 2024期末)

(1) 

重要信息: **内存的基本单位为Byte**, 虚拟地址空间大小为8KB, 页大小为128B, 单个页表项占据2B.

- 推导过程
  - 虚拟地址空间: $8KB = 2^{13}B$ -> 虚拟地址空间有效位为13位(高三位恒为0)
  - 页大小: $128B = 2^7B$ -> VPO需要7位 -> VPN占据13-7=6位 -> 共有$2^6 = 64$个虚拟页
  - 页表大小: $2B * 64 = 128B$ -> 占据1个物理页 **(重点: 虚拟页和物理页大小相同)**
- 答案: `64` `1`
 
---

# 虚拟缓存大题练习

T1 (出处: 2024期末)

(2)

先拆解地址: TLB的set数为$8=2^3$ -> TLBI需要3位 -> TLBT需要6-3=3位

最终地址表达式为: `empty : TLBT : TLBI : VPO = 3 : 3 : 3 : 7`

分解地址得`000 | 001 | 110 | 010 0001`, 即`TLBT = 1`, `TLBI = 6`, 访问TLB得`Valid = 0` **(重点检查)**

因此进一步计算`VPN = 0xE`, 访问页表得`PPN = 0xD`, 把该地址和`VPO`拼接即可 **(重点: VPO恒和PPO相同)**

答案: `0x06A1`

---

# 虚拟缓存大题练习

T1 (出处: 2024期末)

(3)

分别按(2)中的方式拆解五个地址, 得到的TLBT和TLBI以及相应的访问操作如下:

第一次访问: `TLBT = 4, TLBI = 3` (命中TLB, 直接访问物理内存, 一次)

第二次访问: `TLBT = 5, TLBI = 0` (`Valid = 0`, 更新快表, 后由页表访问物理内存, 两次)

第三次访问: `TLBT = 7, TLBI = 0` 

(未命中TLB, 根据LRU策略替换快表`Tag = 2`条目, 后由页表访问物理内存, 两次)

第四次访问: `TLBT = 2, TLBI = 0` 

(由于第三次操作发生了替换, 未命中TLB, 根据LRU策略替换快表`Tag = 5`条目, 后由页表访问物理内存, 两次)

第五次访问: `TLBT = 7, TLBI = 0` (命中TLB, 直接访问物理内存, 一次)

答案: `8`

---

# 虚拟缓存大题练习

T1 (出处: 2024期末)

(4)

对第一个地址, 拆解得`TLBT = 0, TLBI = 1, VPN = 1`, 快表`Valid = 0`, 页表未命中, 对应**缺页异常**

对第二个地址, 显然其高三位没有置零, 超出了虚拟地址空间, 对应**段错误**

答案: `B` `C`

---

# 虚拟缓存大题练习

T1 (出处: 2024期末)

(5)

核心解题思路: 对于多级页表, **页表条目存储下一级页表的基址, $VPN_i$存储页表条目号**

先拆解地址: 页大小$4KB = 2^{12} B$ -> VPO需要12位 -> 2级VPN需要32-12=20位 -> 每级VPN10位

将访问地址的高20位进行拆分得: `00 0110 0100 | 10 0110 0000`, 即$VPN_1 = 0x064, VPN_2 = 0x260$

对应一级页表条目地址: $0x00E77000 + 0x064 * 4 = 0x00E77190$ 

**(注意页表条目号换算为地址时, 还要乘上页大小)**

对应一级页表条目地址: $0x0D000000 + 0x260 * 4 = 0x0D000980$ 

**(注意在Intel系统中, 多级页表的低12位存储的是其它信息, 不需要保留)**

答案: `0x00E77190` `0x0D000980`

---

# 虚拟缓存大题练习

T2 (出处: 2021期末)

(1)

若快表命中, 则可以直接计算得到物理地址, 只需要访问1次物理内存

下面具体拆解地址: 页大小$4KB = 2^{12} B$ -> VPO需要12位 -> 2级VPN需要32-12=20位 -> 每级VPN10位

此外, 对于快表: TLBI需要4位 -> TLBT需要20-4=16位

先用完整VPN计算是否命中TLB, 拆解得即`TLBI = 0x5, TLBT = 0xd551`, 命中得到页表内容`0x019fa42d`

该页表条目的低四位为`1101`, 对应R/W位为0, U/S位为1

答案: `1` `②④`

---

# 虚拟缓存大题练习

T2 (出处: 2021期末)

(2)

若快表未命中, 需要访问页表, 注意**题目中为二级页表**, 故需要访问3次物理内存

对地址的高20位进行分解得`00 0000 0001 | 00 0000 0000`, 即$VPN_1$为`0x1`, 对应页表条目地址为`0x00e66004` **(不要忘记乘条目大小)**

根据**小端法**从上述地址开始读出四字节为`0x00615721`, 忽略低12位为`0x00615000`

由于$VPN_2$为`0x0`, 对应二级页表条目地址为`0x00615000`, 根据**小端法**读出四字节`0xc0ee2021`

同样的, 将低12位替换为原始地址的低12位(PPO), 得到`0xc0ee24d0`, 对应数据`0x48`

答案: `3` `0x00615000` `0x48`

---

# 虚拟缓存大题练习

T2 (出处: 2021期末)

(4)

提炼题干, 重点为: **产生两次故障**

对于①, 内核模式有权限运行用户代码, 不会发生故障

对于②, 调用Ctrl+C对应的是中断而不是故障, 因此只发生了缺页异常这一个故障

对于③, 发生缺页异常时, 由于缺页异常处理程序不在主存中, 又发生了一次缺页异常, 且无法得到解决(递归调用), 符合题意

答案:`③`

---
layout: end
---

# Thanks for listening!